parameters:
  acrName: ''  # Required: ACR name
  resourceGroup: ''  # Required: Resource group name
  services: []  # Required: List of services to build
  dockerBuildArgs: ''  # Optional: Docker build arguments
  maxParallel: 4  # Optional: Maximum parallel builds
  retryCount: 2  # Optional: Number of retries on failure
  timeoutInMinutes: 30  # Optional: Build timeout in minutes
  version: ''  # Required: Build version number
  buildCacheFrom: ''  # Optional: Build cache configuration
  vmImage: 'ubuntu-latest'  # Optional: VM image to use for builds

jobs:
- job: Validate
  displayName: 'Validate and Prepare'
  pool:
    vmImage: ${{ parameters.vmImage }}
  steps:
  - task: AzureCLI@2
    displayName: 'Validate ACR Access'
    inputs:
      azureSubscription: '$(AZURE_SUBSCRIPTION)'
      scriptType: 'bash'
      scriptLocation: 'inlineScript'
      inlineScript: |
        # Check if ACR exists and is accessible
        if ! az acr show -n ${{ parameters.acrName }} -g ${{ parameters.resourceGroup }} &>/dev/null; then
          echo "##vso[task.logissue type=error]ACR ${{ parameters.acrName }} not found or not accessible"
          exit 1
        fi
        
        # Login to ACR
        az acr login --name ${{ parameters.acrName }}
        
        # Check if we can pull images
        for service in $(echo ${{ parameters.services }} | jq -r 'keys[]'); do
          if ! az acr repository show -n ${{ parameters.acrName }} --repository $service &>/dev/null; then
            echo "Repository $service does not exist yet - this is normal for first build"
          else
            echo "Repository $service exists and is accessible"
          fi
        done

- job: Build
  displayName: 'Build and Push Images'
  dependsOn: Validate
  strategy:
    matrix: ${{ parameters.services }}
    maxParallel: ${{ parameters.maxParallel }}
  pool:
    vmImage: ${{ parameters.vmImage }}
  timeoutInMinutes: ${{ parameters.timeoutInMinutes }}
  steps:
  - task: AzureCLI@2
    displayName: 'Login to ACR'
    retryCountOnTaskFailure: ${{ parameters.retryCount }}
    inputs:
      azureSubscription: '$(AZURE_SUBSCRIPTION)'
      scriptType: 'bash'
      scriptLocation: 'inlineScript'
      inlineScript: |
        az acr login --name ${{ parameters.acrName }}

  - task: Docker@2
    displayName: 'Build $(serviceName)'
    retryCountOnTaskFailure: ${{ parameters.retryCount }}
    inputs:
      command: build
      repository: $(serviceName)
      dockerfile: $(dockerfile)
      buildContext: $(context)
      containerRegistry: '${{ parameters.acrName }}'
      tags: |
        ${{ parameters.version }}
        ${{ parameters.version }}-$(Build.SourceVersion)
        latest
      buildOptions: ${{ parameters.dockerBuildArgs }}
      arguments: ${{ parameters.buildCacheFrom }}

  - task: Docker@2
    displayName: 'Push $(serviceName)'
    retryCountOnTaskFailure: ${{ parameters.retryCount }}
    inputs:
      command: push
      repository: $(serviceName)
      containerRegistry: '${{ parameters.acrName }}'
      tags: |
        ${{ parameters.version }}
        ${{ parameters.version }}-$(Build.SourceVersion)
        latest

# Note: ACR handles image retention automatically through retention policies
# Configure retention policies in ACR to manage old images:
# - Set retention period for untagged manifests
# - Configure retention rules based on age and count
# - Use ACR's built-in cleanup features 