parameters:
  # Package Parameters
  packageServices: true  # Whether to build and push images
  packageParallel: 4  # Maximum parallel builds
  packageRetryCount: 2  # Number of retries on build failure
  packageTimeout: 30  # Build timeout in minutes
  
  # Deploy Parameters
  deployEnvironment: 'dev'  # Environment to deploy to (dev, staging, prod)
  deployNamespace: 'online-boutique'  # Kubernetes namespace
  deployReleaseName: 'online-boutique'  # Helm release name
  deployTimeout: '10m'  # Helm deployment timeout
  deployWait: true  # Wait for deployment to complete
  deployAtomic: true  # Rollback on failure
  deployMaxHistory: 5  # Maximum release history
  deployDryRun: false  # Dry run mode for testing
  deployForce: false  # Force deployment even if no changes
  deployCleanupOnFail: true  # Cleanup on failure
  
  # Chart Parameters
  chartPath: 'online-boutique-chart'  # Path to Helm chart
  valuesFile: 'values.yaml'  # Values file to use
  
  # Infrastructure Parameters
  vmImage: 'ubuntu-latest'  # VM image to use
  helmVersion: '3.12.0'  # Helm version to install

trigger: none

variables:
  - group: online-boutique.common
  - group: online-boutique.docker
  - group: online-boutique.kubernetes
  - name: APP_SOURCE_DIR
    value: '$(System.DefaultWorkingDirectory)/src'
  - name: DOCKER_BUILDKIT
    value: '1'
  - name: DOCKER_CLI_EXPERIMENTAL
    value: 'enabled'
  - name: DOCKER_BUILD_ARGS
    value: '--pull'
  - name: BUILD_CACHE_FROM
    value: 'type=registry,ref=$(ACR_NAME).azurecr.io/$(serviceName):$(SEMVER)'
  - name: BUILD_CACHE_TO
    value: 'type=registry,ref=$(ACR_NAME).azurecr.io/$(serviceName):$(SEMVER)'
  - name: BUILD_TEMPLATE
    value: 'docker/acr-build-template.yml'
  - name: DEPLOY_TEMPLATE
    value: 'helm/helm-deploy-template.yml'

stages:
- stage: Version
  displayName: 'Calculate Semantic Version'
  jobs:
  - job: GitVersion
    displayName: 'Run GitVersion'
    pool:
      vmImage: ${{ parameters.vmImage }}
    steps:
      - checkout: self
        fetchDepth: 0
      - task: gitversion/setup@3
        name: gitversionSetup
        inputs:
          versionSpec: '5.x'
      - task: gitversion/execute@3
        name: gitversionExecute
        inputs:
          useConfigFile: false
      - script: |
          echo "##vso[task.setvariable variable=SEMVER;isOutput=true]$(GitVersion.SemVer)"
        name: SetSemver
        displayName: 'Set SEMVER variable'
      - script: |
          echo "Calculated SEMVER is: $(GitVersion.SemVer)"
        displayName: 'Echo SEMVER Output'

- stage: Package
  displayName: 'Package Container Images'
  dependsOn: Version
  condition: and(succeeded(), eq('${{ parameters.packageServices }}', 'true'))
  variables:
    SEMVER: $[ stageDependencies.Version.GitVersion.outputs['SetSemver.SEMVER'] ]
  jobs:
    - job: EchoVersion
      displayName: 'Echo SEMVER in Package Stage'
      steps:
        - script: |
            echo "Using SEMVER: $(SEMVER)"

    - template: ${{ variables.BUILD_TEMPLATE }}
      parameters:
        acrName: $(ACR_NAME)
        resourceGroup: $(RESOURCE_GROUP)
        services:
          cartservice:
            serviceName: cartservice
            dockerfile: '$(APP_SOURCE_DIR)/cartservice/src/Dockerfile'
            context: 'src/cartservice/src'
          productcatalogservice:
            serviceName: productcatalogservice
            dockerfile: '$(APP_SOURCE_DIR)/productcatalogservice/Dockerfile'
            context: 'src/productcatalogservice'
          currencyservice:
            serviceName: currencyservice
            dockerfile: '$(APP_SOURCE_DIR)/currencyservice/Dockerfile'
            context: 'src/currencyservice'
          emailservice:
            serviceName: emailservice
            dockerfile: '$(APP_SOURCE_DIR)/emailservice/Dockerfile'
            context: 'src/emailservice'
          paymentservice:
            serviceName: paymentservice
            dockerfile: '$(APP_SOURCE_DIR)/paymentservice/Dockerfile'
            context: 'src/paymentservice'
          shippingservice:
            serviceName: shippingservice
            dockerfile: '$(APP_SOURCE_DIR)/shippingservice/Dockerfile'
            context: 'src/shippingservice'
          recommendationservice:
            serviceName: recommendationservice
            dockerfile: '$(APP_SOURCE_DIR)/recommendationservice/Dockerfile'
            context: 'src/recommendationservice'
          adservice:
            serviceName: adservice
            dockerfile: '$(APP_SOURCE_DIR)/adservice/Dockerfile'
            context: 'src/adservice'
          checkoutservice:
            serviceName: checkoutservice
            dockerfile: '$(APP_SOURCE_DIR)/checkoutservice/Dockerfile'
            context: 'src/checkoutservice'
          shoppingassistantservice:
            serviceName: shoppingassistantservice
            dockerfile: '$(APP_SOURCE_DIR)/shoppingassistantservice/Dockerfile'
            context: 'src/shoppingassistantservice'
          frontend:
            serviceName: frontend
            dockerfile: '$(APP_SOURCE_DIR)/frontend/Dockerfile'
            context: 'src/frontend'
        maxParallel: ${{ parameters.packageParallel }}
        retryCount: ${{ parameters.packageRetryCount }}
        dockerBuildArgs: $(DOCKER_BUILD_ARGS)
        buildCacheFrom: $(BUILD_CACHE_FROM)
        buildCacheTo: $(BUILD_CACHE_TO)
        timeoutInMinutes: ${{ parameters.packageTimeout }}

- stage: Validate
  displayName: 'Validate Helm Chart'
  dependsOn: Version
  jobs:
  - job: ChartValidation
    displayName: 'Validate Chart Structure'
    pool:
      vmImage: ${{ parameters.vmImage }}
    steps:
      - checkout: self
      - task: HelmInstaller@0
        displayName: 'Install Helm'
        inputs:
          helmVersion: ${{ parameters.helmVersion }}
      - script: |
          # Validate chart structure
          helm lint ${{ parameters.chartPath }}
          if [ $? -ne 0 ]; then
            echo "##vso[task.logissue type=error]Helm chart validation failed"
            exit 1
          fi
          
          # Check dependencies
          helm dependency build ${{ parameters.chartPath }}
          if [ $? -ne 0 ]; then
            echo "##vso[task.logissue type=error]Helm dependency build failed"
            exit 1
          fi
          
          # Dry run to validate values
          helm template ${{ parameters.deployReleaseName }} ${{ parameters.chartPath }} \
            --values ${{ parameters.chartPath }}/${{ parameters.valuesFile }} \
            --namespace ${{ parameters.deployNamespace }} \
            --debug
        displayName: 'Validate Chart and Values'

- stage: Deploy
  displayName: 'Deploy to ${{ parameters.deployEnvironment }}'
  dependsOn: 
    - Version
    - Validate
    - Package
  condition: and(succeeded(), eq(dependencies.Validate.result, 'Succeeded'))
  variables:
    SEMVER: $[ stageDependencies.Version.GitVersion.outputs['SetSemver.SEMVER'] ]
    # Environment-specific variables
    ENVIRONMENT: ${{ parameters.deployEnvironment }}
    NAMESPACE: ${{ parameters.deployNamespace }}
    RELEASE_NAME: ${{ parameters.deployReleaseName }}
  jobs:
    - job: EchoVersion
      displayName: 'Echo Version in Deploy Stage'
      steps:
        - script: |
            echo "Using SEMVER: $(SEMVER)"
            echo "ACR Name: $(ACR_NAME)"
            echo "Environment: $(ENVIRONMENT)"
            echo "Namespace: $(NAMESPACE)"
            echo "Helm Version: ${{ parameters.helmVersion }}"

    - template: ${{ variables.DEPLOY_TEMPLATE }}
      parameters:
        clusterName: $(AKS_CLUSTER_NAME)
        resourceGroup: $(RESOURCE_GROUP)
        namespace: $(NAMESPACE)
        chartPath: ${{ parameters.chartPath }}
        releaseName: $(RELEASE_NAME)
        valuesFile: ${{ parameters.valuesFile }}
        acrName: $(ACR_NAME)
        timeout: ${{ parameters.deployTimeout }}
        helmVersion: ${{ parameters.helmVersion }}
        wait: ${{ parameters.deployWait }}
        atomic: ${{ parameters.deployAtomic }}
        cleanupOnFail: ${{ parameters.deployCleanupOnFail }}
        maxHistory: ${{ parameters.deployMaxHistory }}
        dryRun: ${{ parameters.deployDryRun }}
        force: ${{ parameters.deployForce }}
        timeoutInMinutes: ${{ parameters.packageTimeout }}

- stage: Verify
  displayName: 'Verify ${{ parameters.deployEnvironment }} Deployment'
  dependsOn: Deploy
  condition: succeeded()
  variables:
    ENVIRONMENT: ${{ parameters.deployEnvironment }}
    NAMESPACE: ${{ parameters.deployNamespace }}
    RELEASE_NAME: ${{ parameters.deployReleaseName }}
  jobs:
  - job: HealthCheck
    displayName: 'Health Check - $(ENVIRONMENT)'
    pool:
      vmImage: ${{ parameters.vmImage }}
    steps:
      - task: AzureCLI@2
        displayName: 'Get AKS Credentials'
        inputs:
          azureSubscription: $(AZURE_SUBSCRIPTION)
          scriptType: 'bash'
          scriptLocation: 'inlineScript'
          inlineScript: |
            az aks get-credentials -n $(AKS_CLUSTER_NAME) -g $(RESOURCE_GROUP) --overwrite-existing

      - script: |
          # Wait for all pods to be ready
          kubectl wait --for=condition=ready pod -l app.kubernetes.io/instance=$(RELEASE_NAME) -n $(NAMESPACE) --timeout=300s
          
          # Check pod status
          kubectl get pods -n $(NAMESPACE) -l app.kubernetes.io/instance=$(RELEASE_NAME)
          
          # Check service status
          kubectl get services -n $(NAMESPACE) -l app.kubernetes.io/instance=$(RELEASE_NAME)
          
          # Check deployment status
          kubectl get deployments -n $(NAMESPACE) -l app.kubernetes.io/instance=$(RELEASE_NAME)
          
          # Check image tags being used
          echo "=== Image Tags in Use ==="
          kubectl get pods -n $(NAMESPACE) -l app.kubernetes.io/instance=$(RELEASE_NAME) -o jsonpath='{range .items[*]}{.metadata.name}{"\t"}{.spec.containers[*].image}{"\n"}{end}'
        displayName: 'Verify Pods and Services'

      - script: |
          # Environment-specific health checks
          echo "=== Environment-Specific Health Checks ==="
          
          if [ "$(ENVIRONMENT)" = "dev" ]; then
            echo "Running DEV environment health checks..."
            # Dev-specific checks (e.g., basic connectivity)
            echo "Checking service endpoints..."
            kubectl get endpoints -n $(NAMESPACE) -l app.kubernetes.io/instance=$(RELEASE_NAME)
            
          elif [ "$(ENVIRONMENT)" = "staging" ]; then
            echo "Running STAGING environment health checks..."
            # Staging-specific checks (e.g., integration tests)
            echo "Checking service endpoints..."
            kubectl get endpoints -n $(NAMESPACE) -l app.kubernetes.io/instance=$(RELEASE_NAME)
            
            # Check if services are properly configured
            echo "Checking service configurations..."
            kubectl get services -n $(NAMESPACE) -l app.kubernetes.io/instance=$(RELEASE_NAME) -o wide
            
          elif [ "$(ENVIRONMENT)" = "prod" ]; then
            echo "Running PROD environment health checks..."
            # Prod-specific checks (e.g., performance, security)
            echo "Checking service endpoints..."
            kubectl get endpoints -n $(NAMESPACE) -l app.kubernetes.io/instance=$(RELEASE_NAME)
            
            # Check service configurations
            echo "Checking service configurations..."
            kubectl get services -n $(NAMESPACE) -l app.kubernetes.io/instance=$(RELEASE_NAME) -o wide
            
            # Additional prod checks
            echo "Checking resource usage..."
            kubectl top pods -n $(NAMESPACE) 2>/dev/null || echo "Metrics not available"
            
            # Check pod resource limits
            echo "Checking pod resource limits..."
            kubectl get pods -n $(NAMESPACE) -l app.kubernetes.io/instance=$(RELEASE_NAME) -o jsonpath='{range .items[*]}{.metadata.name}{"\t"}{.spec.containers[*].resources.limits.cpu}{"\t"}{.spec.containers[*].resources.limits.memory}{"\n"}{end}'
          fi
        displayName: 'Environment-Specific Health Checks'

      - script: |
          echo "Deployment verification completed"
          echo "Release: $(RELEASE_NAME)"
          echo "Namespace: $(NAMESPACE)"
          echo "Environment: $(ENVIRONMENT)"
          echo "Using latest images from ACR: $(ACR_NAME).azurecr.io"
          echo "SEMVER: $(SEMVER)"
        displayName: 'Verification Summary' 