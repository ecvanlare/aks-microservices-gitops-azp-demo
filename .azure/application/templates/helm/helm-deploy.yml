parameters:
  # External dependencies
  clusterName: ''
  resourceGroup: ''
  azureSubscription: ''
  # Optional parameters with defaults
  namespace: 'online-boutique'
  chartPath: 'online-boutique-chart'
  releaseName: 'online-boutique'
  valuesFile: 'values.yaml'
  helmVersion: '3.12.0'
  helmTimeout: '10m'
  semver: ''  # Semantic version for deployment (passed from deploy template)

steps:
- task: AzureCLI@2
  displayName: 'Diagnose Pipeline vs Helm Issue'
  inputs:
    azureSubscription: ${{ parameters.azureSubscription }}
    scriptType: 'bash'
    scriptLocation: 'inlineScript'
    inlineScript: |
      set -e
      
      echo "=== PIPELINE DIAGNOSTICS ==="
      
      # Test 1: Azure CLI authentication
      echo "1. Testing Azure CLI authentication..."
      if az account show --query "user.name" -o tsv; then
        echo "✅ Azure CLI authentication: OK"
      else
        echo "❌ Azure CLI authentication: FAILED"
        exit 1
      fi
      
      # Test 2: AKS access
      echo "2. Testing AKS access..."
      if az aks show -n ${{ parameters.clusterName }} -g ${{ parameters.resourceGroup }} --query "name" -o tsv; then
        echo "✅ AKS access: OK"
      else
        echo "❌ AKS access: FAILED"
        exit 1
      fi
      
      # Test 3: kubelogin installation
      echo "3. Testing kubelogin installation..."
      if command -v kubelogin &> /dev/null; then
        echo "✅ kubelogin: INSTALLED"
      else
        echo "❌ kubelogin: NOT FOUND - Installing..."
        curl -LO "https://github.com/Azure/kubelogin/releases/latest/download/kubelogin-linux-amd64.zip"
        unzip kubelogin-linux-amd64.zip
        sudo mv bin/linux_amd64/kubelogin /usr/local/bin/
        chmod +x /usr/local/bin/kubelogin
        echo "✅ kubelogin: INSTALLED"
      fi
      
      # Test 4: K8s credentials
      echo "4. Testing K8s credentials..."
      if az aks get-credentials -n ${{ parameters.clusterName }} -g ${{ parameters.resourceGroup }} --overwrite-existing; then
        echo "✅ K8s credentials: OK"
      else
        echo "❌ K8s credentials: FAILED"
        exit 1
      fi
      
      # Test 5: kubelogin conversion
      echo "5. Testing kubelogin conversion..."
      if kubelogin convert-kubeconfig -l azurecli; then
        echo "✅ kubelogin conversion: OK"
      else
        echo "❌ kubelogin conversion: FAILED"
        exit 1
      fi
      
      # Test 6: K8s API access
      echo "6. Testing K8s API access..."
      if kubectl cluster-info; then
        echo "✅ K8s API access: OK"
      else
        echo "❌ K8s API access: FAILED"
        exit 1
      fi
      
      echo "=== HELM DIAGNOSTICS ==="
      
      # Test 7: Helm chart validation
      echo "7. Testing Helm chart validation..."
      if helm lint ${{ parameters.chartPath }}; then
        echo "✅ Helm chart validation: OK"
      else
        echo "❌ Helm chart validation: FAILED"
        exit 1
      fi
      
      # Test 8: Helm dependencies
      echo "8. Testing Helm dependencies..."
      if helm dependency build ${{ parameters.chartPath }}; then
        echo "✅ Helm dependencies: OK"
      else
        echo "❌ Helm dependencies: FAILED"
        exit 1
      fi
      
      echo "=== SUMMARY ==="
      echo "✅ All diagnostics passed - Ready for deployment!"

- task: AzureCLI@2
  displayName: 'Setup AKS Access'
  inputs:
    azureSubscription: ${{ parameters.azureSubscription }}
    scriptType: 'bash'
    scriptLocation: 'inlineScript'
    inlineScript: |
      set -e
      
      # Install kubelogin for AAD-enabled clusters
      echo "Installing kubelogin..."
      curl -LO "https://github.com/Azure/kubelogin/releases/latest/download/kubelogin-linux-amd64.zip"
      unzip kubelogin-linux-amd64.zip
      sudo mv bin/linux_amd64/kubelogin /usr/local/bin/
      chmod +x /usr/local/bin/kubelogin
      
      # Get current service principal info
      echo "Current service principal:"
      az account show --query "user.name" -o tsv
      
      # Get AKS credentials using service principal
      echo "Getting AKS credentials..."
      az aks get-credentials -n ${{ parameters.clusterName }} -g ${{ parameters.resourceGroup }} --overwrite-existing
      
      # Configure kubelogin to use Azure CLI authentication
      echo "Configuring kubelogin for Azure CLI authentication..."
      kubelogin convert-kubeconfig -l azurecli
      
      # Test kubectl access with retry logic
      echo "Testing kubectl access..."
      max_attempts=5
      attempt=1
      
      while [ $attempt -le $max_attempts ]; do
        echo "Attempt $attempt of $max_attempts"
        
        if kubectl auth can-i get nodes 2>/dev/null; then
          echo "✅ Can access nodes"
          break
        else
          echo "❌ Cannot access nodes, attempt $attempt failed"
          if [ $attempt -lt $max_attempts ]; then
            echo "Waiting 30 seconds before retry..."
            sleep 30
          fi
          attempt=$((attempt + 1))
        fi
      done
      
      if [ $attempt -gt $max_attempts ]; then
        echo "❌ Failed to access cluster after $max_attempts attempts"
        echo "This might be due to role propagation delay. Please wait 10-15 minutes and retry."
        exit 1
      fi
      
      # Test namespace creation permission
      if kubectl auth can-i create namespace 2>/dev/null; then
        echo "✅ Can create namespace"
      else
        echo "⚠️ Cannot create namespace, will try anyway"
      fi
      
      # Create namespace if it doesn't exist
      echo "Creating namespace..."
      kubectl create namespace ${{ parameters.namespace }} --dry-run=client -o yaml | kubectl apply -f -
      
      # Verify connection
      echo "Verifying cluster connection..."
      kubectl cluster-info
      kubectl get nodes

- task: HelmInstaller@1
  displayName: 'Install Helm'
  inputs:
    helmVersion: ${{ parameters.helmVersion }}

- script: |
    set -e
    helm lint ${{ parameters.chartPath }}
    helm dependency build ${{ parameters.chartPath }}
  displayName: 'Validate Chart'

- task: AzureCLI@2
  displayName: 'Prepare Image Tags'
  inputs:
    azureSubscription: ${{ parameters.azureSubscription }}
    scriptType: 'bash'
    scriptLocation: 'inlineScript'
    inlineScript: |
      set -e
      
      # Function to get best available tag
      get_best_tag() {
        local service_name=$1
        local tag=$(az acr repository show-tags -n $(ACR_NAME) --repository $service_name --orderby time_desc --top 1 --query '[0]' -o tsv 2>/dev/null)
        echo "${tag:-latest}"
      }
      
      # Check if specific SEMVER exists, otherwise get best tag
      check_tag() {
        local service_name=$1
        local semver=$2
        local exists=$(az acr repository show-tags -n $(ACR_NAME) --repository $service_name --query "[?contains(@, '$semver')]" --output tsv 2>/dev/null)
        if [ -n "$exists" ]; then
          echo "$semver"
        else
          get_best_tag "$service_name"
        fi
      }
      
      # Get tags for all services
      if [ -n "${{ parameters.semver }}" ]; then
        AD_TAG=$(check_tag "adservice" "${{ parameters.semver }}")
        CART_TAG=$(check_tag "cartservice" "${{ parameters.semver }}")
        CHECKOUT_TAG=$(check_tag "checkoutservice" "${{ parameters.semver }}")
        CURRENCY_TAG=$(check_tag "currencyservice" "${{ parameters.semver }}")
        EMAIL_TAG=$(check_tag "emailservice" "${{ parameters.semver }}")
        FRONTEND_TAG=$(check_tag "frontend" "${{ parameters.semver }}")
        PAYMENT_TAG=$(check_tag "paymentservice" "${{ parameters.semver }}")
        PRODUCT_TAG=$(check_tag "productcatalogservice" "${{ parameters.semver }}")
        RECOMMENDATION_TAG=$(check_tag "recommendationservice" "${{ parameters.semver }}")
        SHIPPING_TAG=$(check_tag "shippingservice" "${{ parameters.semver }}")
        SHOPPING_ASSISTANT_TAG=$(check_tag "shoppingassistantservice" "${{ parameters.semver }}")
      else
        AD_TAG=$(get_best_tag "adservice")
        CART_TAG=$(get_best_tag "cartservice")
        CHECKOUT_TAG=$(get_best_tag "checkoutservice")
        CURRENCY_TAG=$(get_best_tag "currencyservice")
        EMAIL_TAG=$(get_best_tag "emailservice")
        FRONTEND_TAG=$(get_best_tag "frontend")
        PAYMENT_TAG=$(get_best_tag "paymentservice")
        PRODUCT_TAG=$(get_best_tag "productcatalogservice")
        RECOMMENDATION_TAG=$(get_best_tag "recommendationservice")
        SHIPPING_TAG=$(get_best_tag "shippingservice")
        SHOPPING_ASSISTANT_TAG=$(get_best_tag "shoppingassistantservice")
      fi
      
      # Show tags being used
      echo "Using image tags:"
      echo "  adservice: $AD_TAG"
      echo "  cartservice: $CART_TAG"
      echo "  checkoutservice: $CHECKOUT_TAG"
      echo "  currencyservice: $CURRENCY_TAG"
      echo "  emailservice: $EMAIL_TAG"
      echo "  frontend: $FRONTEND_TAG"
      echo "  paymentservice: $PAYMENT_TAG"
      echo "  productcatalogservice: $PRODUCT_TAG"
      echo "  recommendationservice: $RECOMMENDATION_TAG"
      echo "  shippingservice: $SHIPPING_TAG"
      echo "  shoppingassistantservice: $SHOPPING_ASSISTANT_TAG"
      
      # Create values override
      cat > values-override.yaml << EOF
      global:
        image:
          registry: $(ACR_NAME).azurecr.io
        imagePullPolicy: Always
      adservice:
        image:
          tag: $AD_TAG
      cartservice:
        image:
          tag: $CART_TAG
      checkoutservice:
        image:
          tag: $CHECKOUT_TAG
      currencyservice:
        image:
          tag: $CURRENCY_TAG
      emailservice:
        image:
          tag: $EMAIL_TAG
      frontend:
        image:
          tag: $FRONTEND_TAG
      paymentservice:
        image:
          tag: $PAYMENT_TAG
      productcatalogservice:
        image:
          tag: $PRODUCT_TAG
      recommendationservice:
        image:
          tag: $RECOMMENDATION_TAG
      shippingservice:
        image:
          tag: $SHIPPING_TAG
      shoppingassistantservice:
        image:
          tag: $SHOPPING_ASSISTANT_TAG
      EOF

- script: |
    set -e
    helm upgrade --install ${{ parameters.releaseName }} ${{ parameters.chartPath }} \
      --namespace ${{ parameters.namespace }} \
      --values ${{ parameters.chartPath }}/${{ parameters.valuesFile }} \
      --values values-override.yaml \
      --timeout ${{ parameters.helmTimeout }} \
      --wait \
      --atomic \
      --cleanup-on-fail
  displayName: 'Deploy with Helm'
  env:
    HELM_EXPERIMENTAL_OCI: 1

- script: |
    set -e
    kubectl wait --for=condition=ready pod -l app.kubernetes.io/instance=${{ parameters.releaseName }} -n ${{ parameters.namespace }} --timeout=300s
    kubectl get pods -n ${{ parameters.namespace }} -l app.kubernetes.io/instance=${{ parameters.releaseName }}
  displayName: 'Verify Deployment'

- script: |
    echo "Deployment completed successfully"
    echo "Release: ${{ parameters.releaseName }}"
    echo "Namespace: ${{ parameters.namespace }}"
    echo "Using images from ACR: ${{ parameters.acrName }}.azurecr.io"
    if [ -n "${{ parameters.semver }}" ]; then
      echo "Deployed SEMVER: ${{ parameters.semver }}"
    else
      echo "Deployed latest tags"
    fi
  displayName: 'Deployment Summary'

# Alternative approach using Kubernetes task (uncomment if AzureCLI approach fails)
# - task: Kubernetes@1
#   displayName: 'Setup AKS Access with Kubernetes Task'
#   inputs:
#     connectionType: 'Azure Resource Manager'
#     azureSubscription: ${{ parameters.azureSubscription }}
#     azureResourceGroup: ${{ parameters.resourceGroup }}
#     kubernetesCluster: ${{ parameters.clusterName }}
#     namespace: ${{ parameters.namespace }}
#     command: 'create'
#     arguments: 'namespace ${{ parameters.namespace }} --dry-run=client -o yaml | kubectl apply -f -'
#     secretType: 'dockerRegistry'
#     secretArguments: '--docker-server=$(ACR_NAME).azurecr.io --docker-username=$(ACR_USERNAME) --docker-password=$(ACR_PASSWORD) --docker-email=test@test.com'

# Alternative approach using Helm task (most reliable for Helm deployments with WIF)
# - task: HelmDeploy@0
#   displayName: 'Deploy with Helm Task'
#   inputs:
#     connectionType: 'Azure Resource Manager'
#     azureSubscription: ${{ parameters.azureSubscription }}
#     azureResourceGroup: ${{ parameters.resourceGroup }}
#     kubernetesCluster: ${{ parameters.clusterName }}
#     namespace: ${{ parameters.namespace }}
#     command: 'upgrade'
#     chartType: 'FilePath'
#     chartPath: '${{ parameters.chartPath }}'
#     releaseName: '${{ parameters.releaseName }}'
#     valueFile: '${{ parameters.chartPath }}/${{ parameters.valuesFile }}'
#     installFlags: '--wait --atomic --timeout ${{ parameters.helmTimeout }}'