# Argo CD Deployment Template
# Deploys Argo CD and infrastructure components using Helm

parameters:
  # Argo CD configuration
  argocdNamespace: 'argocd'
  argocdReleaseName: 'argocd'
  argocdChartPath: 'helm-charts/infra-chart'
  argocdValuesFile: 'values.yaml'
  
  # Infrastructure configuration
  infraNamespace: 'infra'
  infraReleaseName: 'infrastructure'
  infraChartPath: 'helm-charts/infra-chart'
  infraValuesFile: 'values.yaml'
  
  # GitOps configuration
  gitopsRepoUrl: $(GITOPS_REPO_URL)
  gitopsBranch: $(GITOPS_BRANCH)
  gitopsPath: 'gitops'
  
  # Deployment settings
  vmImage: 'ubuntu-22.04'
  helmVersion: '3.12.0'
  helmTimeout: '10m'
  podReadyTimeout: 300
  clusterName: $(AKS_CLUSTER_NAME)
  
  # Azure configuration
  acrName: $(ACR_NAME)
  resourceGroup: $(RESOURCE_GROUP)
  azureSubscription: $(AZURE_SUBSCRIPTION)
  
  # Version configuration
  semver: ''
  
  # Deployment options
  deployArgoCD: true
  deployInfrastructure: true
  waitForArgoCD: true
  createGitOpsApps: true
  updateApplication: true

steps:
  # ========================================
  # SECTION 1: CHECKOUT AND SETUP
  # ========================================
  - checkout: self
    fetchDepth: 0

  - task: AzureCLI@2
    displayName: 'Get AKS Credentials'
    inputs:
      azureSubscription: $(AZURE_SUBSCRIPTION)
      scriptType: 'bash'
      scriptLocation: 'inlineScript'
      inlineScript: |
        az aks get-credentials -n $(AKS_CLUSTER_NAME) -g $(RESOURCE_GROUP) --overwrite-existing
        kubelogin convert-kubeconfig -l azurecli

  # ========================================
  # SECTION 2: INSTALL HELM
  # ========================================
  - task: HelmInstaller@0
    displayName: 'Install Helm'
    inputs:
      helmVersion: ${{ parameters.helmVersion }}

  # ========================================
  # SECTION 3: ADD HELM REPOSITORIES
  # ========================================
  - script: |
      helm repo add argo https://argoproj.github.io/argo-helm
      helm repo add jetstack https://charts.jetstack.io
      helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
      helm repo add external-dns https://kubernetes-sigs.github.io/external-dns
      helm repo update
    displayName: 'Add Helm Repositories'

  # ========================================
  # SECTION 4: DEPLOY ARGO CD
  # ========================================
  - ${{ if eq(parameters.deployArgoCD, 'true') }}:
    - script: |
        # Create Argo CD namespace if it doesn't exist
        kubectl create namespace ${{ parameters.argocdNamespace }} --dry-run=client -o yaml | kubectl apply -f -
        
        # Install Argo CD
        helm upgrade --install ${{ parameters.argocdReleaseName }} argo/argo-cd \
          --namespace ${{ parameters.argocdNamespace }} \
          --create-namespace \
          --timeout ${{ parameters.helmTimeout }} \
          --wait \
          --set server.extraArgs="{--insecure}" \
          --set server.ingress.enabled=false \
          --set server.service.type=ClusterIP \
          --set controller.resources.requests.memory=256Mi \
          --set controller.resources.requests.cpu=100m \
          --set controller.resources.limits.memory=512Mi \
          --set controller.resources.limits.cpu=200m \
          --set repoServer.resources.requests.memory=256Mi \
          --set repoServer.resources.requests.cpu=100m \
          --set repoServer.resources.limits.memory=512Mi \
          --set repoServer.resources.limits.cpu=200m \
          --set applicationSet.enabled=false \
          --set notifications.enabled=false \
          --set dex.enabled=false
      displayName: 'Deploy Argo CD'
      env:
        KUBECONFIG: $(KUBECONFIG)

  # ========================================
  # SECTION 5: WAIT FOR ARGO CD TO BE READY
  # ========================================
  - ${{ if and(eq(parameters.deployArgoCD, 'true'), eq(parameters.waitForArgoCD, 'true')) }}:
    - script: |
        echo "Waiting for Argo CD to be ready..."
        kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=argocd-server -n ${{ parameters.argocdNamespace }} --timeout=300s
        kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=argocd-repo-server -n ${{ parameters.argocdNamespace }} --timeout=300s
        kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=argocd-application-controller -n ${{ parameters.argocdNamespace }} --timeout=300s
        
        echo "Argo CD is ready!"
        kubectl get pods -n ${{ parameters.argocdNamespace }}
      displayName: 'Wait for Argo CD Ready'
      env:
        KUBECONFIG: $(KUBECONFIG)

  # ========================================
  # SECTION 6: GET ARGO CD ADMIN PASSWORD
  # ========================================
  - ${{ if eq(parameters.deployArgoCD, 'true') }}:
    - script: |
        # Get Argo CD admin password
        ARGO_PASSWORD=$(kubectl -n ${{ parameters.argocdNamespace }} get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d)
        echo "##vso[task.setvariable variable=ARGO_PASSWORD]$ARGO_PASSWORD"
        echo "Argo CD admin password retrieved"
      displayName: 'Get Argo CD Admin Password'
      env:
        KUBECONFIG: $(KUBECONFIG)

  # ========================================
  # SECTION 7: CREATE GITOPS APPLICATIONS
  # ========================================
  - ${{ if and(eq(parameters.deployArgoCD, 'true'), eq(parameters.createGitOpsApps, 'true')) }}:
    - script: |
        # Create infra namespace
        kubectl create namespace ${{ parameters.infraNamespace }} --dry-run=client -o yaml | kubectl apply -f -
        
        # Create GitHub authentication secret (if using HTTPS)
        kubectl create secret generic github-repo-secret \
          --from-literal=username=git \
          --from-literal=password=$(GITHUB_TOKEN) \
          -n argocd \
          --dry-run=client -o yaml | kubectl apply -f -
        
        # Apply infrastructure application
        cat <<EOF | kubectl apply -f -
        apiVersion: argoproj.io/v1alpha1
        kind: Application
        metadata:
          name: infrastructure
          namespace: ${{ parameters.infraNamespace }}
          finalizers:
            - resources-finalizer.argocd.argoproj.io
        spec:
          project: default
          source:
            repoURL: ${{ parameters.gitopsRepoUrl }}
            targetRevision: ${{ parameters.gitopsBranch }}
            path: ${{ parameters.gitopsPath }}/infrastructure
          destination:
            server: https://kubernetes.default.svc
            namespace: ${{ parameters.infraNamespace }}
          syncPolicy:
            automated:
              prune: true
              selfHeal: true
            syncOptions:
              - CreateNamespace=true
          revisionHistoryLimit: 10
        EOF
        
        # Apply application of applications
        cat <<EOF | kubectl apply -f -
        apiVersion: argoproj.io/v1alpha1
        kind: Application
        metadata:
          name: app-of-apps
          namespace: argocd
          finalizers:
            - resources-finalizer.argocd.argoproj.io
        spec:
          project: default
          source:
            repoURL: ${{ parameters.gitopsRepoUrl }}
            targetRevision: ${{ parameters.gitopsBranch }}
            path: ${{ parameters.gitopsPath }}/applications
          destination:
            server: https://kubernetes.default.svc
            namespace: argocd
          syncPolicy:
            automated:
              prune: true
              selfHeal: true
          revisionHistoryLimit: 10
        EOF
        
        echo "GitOps applications created"
      displayName: 'Create GitOps Applications'
      env:
        KUBECONFIG: $(KUBECONFIG)

  # ========================================
  # SECTION 8: DEPLOY INFRASTRUCTURE COMPONENTS
  # ========================================
  - ${{ if eq(parameters.deployInfrastructure, 'true') }}:
    - script: |
        # Create infra namespace
        kubectl create namespace ${{ parameters.infraNamespace }} --dry-run=client -o yaml | kubectl apply -f -
        
        # Install cert-manager
        helm upgrade --install cert-manager jetstack/cert-manager \
          --namespace ${{ parameters.infraNamespace }} \
          --create-namespace \
          --timeout ${{ parameters.helmTimeout }} \
          --wait \
          --set installCRDs=true \
          --set global.leaderElection.namespace=${{ parameters.infraNamespace }}
        
        # Install ingress-nginx
        helm upgrade --install ingress-nginx ingress-nginx/ingress-nginx \
          --namespace ${{ parameters.infraNamespace }} \
          --create-namespace \
          --timeout ${{ parameters.helmTimeout }} \
          --wait \
          --set controller.service.type=LoadBalancer \
          --set controller.resources.requests.memory=256Mi \
          --set controller.resources.requests.cpu=100m \
          --set controller.resources.limits.memory=512Mi \
          --set controller.resources.limits.cpu=200m
        
        # Install external-dns (if configured)
        if [ ! -z "$(EXTERNAL_DNS_ENABLED)" ] && [ "$(EXTERNAL_DNS_ENABLED)" = "true" ]; then
          helm upgrade --install external-dns external-dns/external-dns \
            --namespace ${{ parameters.infraNamespace }} \
            --create-namespace \
            --timeout ${{ parameters.helmTimeout }} \
            --wait \
            --set provider=azure \
            --set azure.resourceGroup=$(RESOURCE_GROUP) \
            --set azure.subscriptionId=$(AZURE_SUBSCRIPTION_ID) \
            --set azure.tenantId=$(AZURE_TENANT_ID) \
            --set azure.useManagedIdentityExtension=true \
            --set azure.userAssignedIdentityID=$(EXTERNAL_DNS_IDENTITY_ID)
        fi
        
        echo "Infrastructure components deployed"
      displayName: 'Deploy Infrastructure Components'
      env:
        KUBECONFIG: $(KUBECONFIG)

  # ========================================
  # SECTION 9: VERIFICATION
  # ========================================
  - script: |
      echo "=== Argo CD Status ==="
      kubectl get pods -n ${{ parameters.argocdNamespace }}
      
      echo "=== Infrastructure Status ==="
      kubectl get pods -n ${{ parameters.infraNamespace }}
      
      echo "=== Argo CD Applications ==="
      kubectl get applications -n argocd
      kubectl get applications -n ${{ parameters.infraNamespace }}
      
      echo "=== Services ==="
      kubectl get services -n ${{ parameters.infraNamespace }}
      
      echo "=== Ingress ==="
      kubectl get ingress -n ${{ parameters.infraNamespace }}
    displayName: 'Verify Deployment'
    env:
      KUBECONFIG: $(KUBECONFIG)

  # ========================================
  # SECTION 10: UPDATE APPLICATION VALUES
  # ========================================
  - ${{ if and(eq(parameters.deployArgoCD, 'true'), eq(parameters.updateApplication, 'true')) }}:
    - template: update-app-values.yml
      parameters:
        appNamespace: 'online-boutique'
        appReleaseName: 'online-boutique'
        chartPath: 'gitops/helm-charts/app-chart'
        valuesFile: 'values.yaml'
        acrName: $(ACR_NAME)
        semver: ${{ parameters.semver }}
        argocdNamespace: ${{ parameters.argocdNamespace }}
        gitopsRepoUrl: ${{ parameters.gitopsRepoUrl }}
        gitopsBranch: ${{ parameters.gitopsBranch }}
        resourceGroup: $(RESOURCE_GROUP)
        azureSubscription: $(AZURE_SUBSCRIPTION)

  # ========================================
  # SECTION 11: OUTPUT ARGO CD ACCESS INFO
  # ========================================
  - ${{ if eq(parameters.deployArgoCD, 'true') }}:
    - script: |
        echo "##vso[task.logissue type=warning]Argo CD Access Information:"
        echo "##vso[task.logissue type=warning]URL: http://localhost:8080 (use kubectl port-forward)"
        echo "##vso[task.logissue type=warning]Username: admin"
        echo "##vso[task.logissue type=warning]Password: $(ARGO_PASSWORD)"
        echo "##vso[task.logissue type=warning]To access Argo CD: kubectl port-forward svc/argocd-server 8080:80 -n ${{ parameters.argocdNamespace }}"
      displayName: 'Output Argo CD Access Info' 